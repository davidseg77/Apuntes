# Info del curso Aprender Python 3 desde cero de OW

## 1. Introducción a Python 3

**Instalación en Linux y Windows**

Para saber si ya lo tenemos instalado:

``` 
python3 --version
``` 

La página principal para descargar las distintas versiones es: www.python.org/downloads/.

A pesar de ello, Python viene preinstalado de serie en la mayoría de las distribuciones GNU/Linux. Si no tenemos a nuestra disposición paquetes para instalarlo.

En **Windows** es aún más sencillo de descargar. Cuando este hecho, para asegurarnos indicamos en la terminal python, y nos mostrará su versión.

**Escribir y ejecutar programas Python**

* Uso del interprete

Al instalar python3 el ejecutable del interprete lo podemos encontrar en /usr/bin/python3 (en debian Stretch). Este directorio por defecto está en el PATH, por lo tanto lo podemos ejecutar directamente en el terminal, para ello ejecutamos:

```
$ python3
Python 3.5.3 (default, Jan 19 2017, 14:11:04) 
[GCC 6.3.0 20170118] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
``` 

* A partir de un fichero con el código fuente
  
Si tenemos nuestro programa en un fichero fuente (suele tener extensión py), por ejemplo programa.py,lo ejecutaríamos de la siguiente manera.

``` 
$ python3 programa.py
``` 

**Mi primer programa en Python**

Vamos a escribir nuestro primer programa para estudiar la estructura de un programa en python3.

- Pseudocódigo

El programa que vamos a realizar es el siguiente: Programa que pida la edad y diga si es mayor de edad. Después de realizar el análisis y el diseño realizamos un pseudocódigo como este:

``` 
Proceso mayor_edad
    Definir edad como entero;
    Escribir "Dime tu edad:";
    Leer edad;
    Si edad>=18 Entonces
        Escribir "Eres mayor de edad";
    FinSi
    Escribir "Programa terminado";
FinProceso
``` 

- Codificación
  
A partir de este pseudocódigo podemos realizar un programa en python3 que sería similar a este:

``` 
# Programa que pida la edad y diga si es mayor de edad.
edad=int(input("Dime tu edad:"))
if edad>=18:
    print("Eres mayor de edad")
print("Programa Terminado")
``` 

- Estructura del programa

* Un programa python está formado por instrucciones que acaban en un carácter de “salto de línea”.
* Una línea empieza en la primera posición, si tenemos instrucciones dentro de un bloque de una estructura de control de flujo habrá que hacer una identación.
* La identación se puede hacer con espacios y tabulaciones pero ambos tipos no se pueden mezclar. Se recomienda usar 4 espacios.
* La barra invertida “\” al final de línea se emplea para dividir una línea muy larga en dos o más líneas.
* Se utiliza el carácter # para indicar los comentarios.


## 2. Tipos de datos básicos

### 2.1 Datos y tipos de datos

**Literales, variables y expresiones**

* Literales

Los literales nos permiten representar valores. Estos valores pueden ser de diferentes tipos, de esta manera tenemos diferentes tipos de literales:

* Literales numéricos

Para representar números enteros utilizamos cifras enteras (Ejemplos: 3, 12, -23).
Para los números reales utilizamos un punto para separar la parte entera de la decimal (12.3, 45.6). Podemos indicar que la parte decimal es 0, por ejemplo 10., o la parte entera es 0, por ejemplo .001.

* Literales cadenas

Nos permiten representar cadenas de caracteres. Para delimitar las cadenas podemos usar el carácter ‘ o el carácter “. También podemos utilizar la combinación ‘’’ cuando la cadena ocupa más de una línea. Ejemplos.

'hola que tal!'
"Muy bien"
'''Podemos \n
ir al cine'''

El caracter \n es el retorno de carro (los siguientes caracteres se escriben en una nueva línea).

* Variables

Una variables es un identificador que referencia a un valor. Para que una variable referencia a un valor se utiliza el operador de asignación =.

El nombre de una variable, ha de empezar por una letra o por el carácter guión bajo, seguido de letras, números o guiones bajos.

``` 
>>> var = 5
>>> var
5
``` 

Hay que tener en cuanta que python distingue entre mayúsculas y minúsculas en el nombre de una variable, pero se recomienda usar sólo minúsculas.

* Expresiones

Una expresión es una combinación de variables, literales, operadores, funciones y expresiones, que tras su evaluación o cálculo nos devuelven un valor de un determinado tipo.

Veamos ejemplos de expresiones:

```
a + 7
(a ** 2) + b
``` 

* Operadores. Precedencia de operadores en python

Los operadores que podemos utilizar se clasifican según el tipo de datos con los que trabajen y podemos poner algunos ejemplos:

- Operadores aritméticos: +, -, *, /, //, %, **.
- Operadores de cadenas: +, *
- Operadores de asignación: =
- Operadores de comparación: ==, !=, >=, >, <=, <
- Operadores lógicos: and, or, not
- Operadores de pertenencia: in, not in

La precedencia de operadores es la siguiente:

Los paréntesis rompen la precedencia.
La potencia (**)
Operadores unarios (+ -)
Multiplicar, dividir, módulo y división entera (* % // )
Suma y resta (+ -)
Operador binario AND (&)
Operadores binario OR y XOR (^ |)
Operadores de comparación (<= < > >=)
Operadores de igualdad (<> == !=)
Operadores de asignación (=)
Operadores de pertenencia (in, in not)
Operadores lógicos (not, or, and)

* Tipos de datos

En python existen muchos tipos de datos, nosotros en este curso vamos a trabajar con los siguientes:

- Tipos numéricos
- Tipo entero (int)
- Tipo real (float)
- Tipos booleanos (bool)
- Tipo de datos secuencia
- Tipo lista (list)
- Tipo tuplas (tuple)
- Tipo de datos cadenas de caracteres
- Tipo cadena (str)
- Tipo de datos mapas o diccionario (dict)

* Función type()

La función type nos devuelve el tipo de dato de un objeto dado. Por ejemplo:

``` 
>>> type(5)
<class 'int'>
>>> type(5.5)
<class 'float'>
>>> type("hola")
<class 'str'>
>>> type([1,2])
<class 'list'>
``` 

### 2.2 Datos numéricos

Python3 trabaja con varios tipos numéricos, pero en este curso sólo vamos a utilizar dos:

* Enteros (int): Representan todos los números enteros (positivos, negativos y 0), sin parte decimal. En python3 este tipo no tiene limitación de espacio.
* Reales (float): Sirve para representar los números reales, tienen una parte decimal y otra decimal. Normalmente se utiliza para su implementación un tipo double de C.

Ejemplos

``` 
>>> entero = 7
>>> type(entero)
<class 'int'>
>>> real = 7.2
>>> type (real)
<class 'float'
``` 

**Operadores aritméticos**

+: Suma dos números
-: Resta dos números
*: Multiplica dos números
/: Divide dos números, el resultado es float.
//: División entera
%: Módulo o resto de la división
**: Potencia
+, -: Operadores unarios positivo y negativo

**Funciones predefinidas que trabajan con números:**

abs(x): Devuelve al valor absoluto de un número.
divmod(x,y): Toma como parámetro dos números, y devuelve una tubla con dos valores, la división entera, y el módulo o resto de la división.
hex(x): Devuelve una cadena con la representación hexadecimal del número que recibe como parámetro.
bin(x): Devuelve una cadena con la representación binaria del número que recibe como parámetro.
pow(x,y): Devuelve la potencia de la base x elevado al exponente y. Es similar al operador**`.
round(x,[y]): Devuelve un número real (float) que es el redondeo del número recibido como parámetro, podemos indicar un parámetro opcional que indica el número de decimales en el redondeo.

Ejemplos

``` 
>>> abs(-7)
7
>>> divmod(7,2)
(3, 1)
>>> hex(255)
'0xff'
>>> pow(2,3)
8
>>> round(7.567,1)
7.6
``` 

**Conversión de tipos**

int(x): Convierte el valor a entero.
float(x): Convierte el valor a float.
Los valores que se reciben también pueden ser cadenas de caracteres (str).

Ejemplos

``` 
>>> a=int(7.2)
>>> a
7
>>> type(a)
<class 'int'>
>>> a=int("345")
>>> a
345
>>> type(a)
<class 'int'>
>>> b=float(1)
>>> b
1.0
>>> type(b)
<class 'float'>
>>> b=float("1.234")
>>> b
1.234
>>> type(b)
<class 'float'>
```

Por último si queremos convertir una cadena a entero, la cadena debe estar formada por caracteres numéricos, sino es así, obtenemos un error:

``` 
a=int("123.3")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '123.3'
```

**Otras operaciones**

Quizás eches en falta más operaciones que podemos realizar sobre los números. En el módulo math encontramos muchas de estas operaciones. Para utilizarlas vamos a importar el módulo, por ejemplo para realizar una raíz cuadrada:

``` 
>>> import math
>>> math.sqrt(9)
3.0
``` 

### 2.3 Datos booleanos (lógicos)

El tipo booleano o lógico se considera en python3 como un subtipo del tipo entero. Se puede representar dos valores: verdadero o false (True, False).

**¿Qué valores se interpretan como FALSO?**

Cuando se evalúa una expresión, hay determinados valores que se interpretan como False:

* False

Cualquier número 0. (0, 0.0)
Cualquier secuencia vacía ([], (), ‘’)
Cualquier diccionario vacío ({})

**Operadores de comparación**

Las expresiones lógicas utilizan operadores de comparación, me permiten comparar dos valores y devuelven un valor booleano, dependiendo de lo que este comparando.

``` 
==: Igual que
!=: Distinto que
>: Mayor que
<: Menor que
<=: Menor o igual
>=: Mayor o igual
```

**Operadores booleanos o lógicos**

Los operadores booleanos se utilizan para operar sobre expresiones booleanas y se suelen utilizar en las estructuras de control alternativas (if, while):

* x or y: Si x es falso entonces y, sino x. Este operados sólo evalúa el segundo argumento si el primero es False.
* x and y: Si x es falso entonces x, sino y. Este operados sólo evalúa el segundo argumento si el primero es True.
* not x: Si x es falso entonces True, sino False.


### 2.4 Trabajando con variables

Una variables es un identificador que referencia a un valor. No hay que declarar la variable antes de usarla, el tipo de la variable será el mismo que el del valor al que hace referencia. Por lo tanto su tipo puede cambiar en cualquier momento:

``` 
>>> var = 5
>>> type(var)
<class 'int'>
>>> var = "hola"
>>> type(var)
<class 'str'>
``` 

**Creación, borrado y ámbito de variables**

Como hemos comentado anteriormente para crear una variable simplemente tenemos que utilizar un operador de asignación, el más utilizado = para que referencia un valor. Si queremos borrar la variable utilizamos la instrucción del. Por ejemplo:

``` 
>>> a = 5
>>> a
5
>>> del a
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
``` 

El ámbito de una variable se refiere a la zona del programa donde se ha definido y existe esa variable. Como primera aproximación las variables creadas dentro de funciones o clases tienen un ámbito local, es decir no existen fuera de la función o clase. Concretaremos cuando estudiamos estos aspectos más profundamente.

**Modificación del valor de una variable**

En cualquier momento podemos cambiar el valor de una variable, asignándole un nuevo valor:

``` 
>>> a = 5
>>> a
5
>>> a = 8
>>> a
8
``` 

También podemos modificar el valor de una variable, por ejemplo si queremos incrementarla en uno, podríamos usar:

``` 
>>> a = a + 1
``` 

Aunque también podemos utilizar otro operador de asignación:

```
>>> a+=1
``` 
Otros operadores de asignación: +=, -=, *=, /=, %=, **=, //=.

### 2.5 Función de entrada y salida

**Función input**

No permite leer por teclado información. Devuelve una cadena de caracteres y puede tener como argumento una cadena que se muestra en pantalla.

Ejemplos

``` 
>>> nombre=input("Nombre:")
Nombre:jose
>>> nombre
'jose'
>>> edad=int(input("Edad:"))
Edad:23
>>> edad
23
``` 

**Función print**

No permite escribir en la salida estándar. Podemos indicar varios datos a imprimir, que por defecto serán separado por un espacio. Podemos también imprimir varias cadenas de texto utilizando la concatenación.

Ejemplos

``` 
>>> print(1,2,3)
1 2 3

>>> print("Hola son las",6,"de la tarde")
Hola son las 6 de la tarde

>>> print("Hola son las "+str(6)+" de la tarde")
Hola son las 6 de la tarde
```

**Formateando cadenas de caracteres**

Con la función print Podemos indicar el formato con el que se va a mostrar los datos, por ejemplo:

``` 
>>> print("%d %f %s" % (2.5,2.5,2.5))
2 2.500000 2.5

>>> print("El producto %s cantidad=%d precio=%.2f"%("cesta",23,13.456))
El producto cesta cantidad=23 precio=13.46   
``` 

### 2.6 Cadenas de caracteres

Las cadenas de caracteres (str): Me permiten guardar secuencias de caracteres.

**Definición de cadenas**

Podemos definir una cadena de caracteres de distintas formas:

``` 
>>> cad1 = "Hola"
>>> cad2 = '¿Qué tal?'
>>> cad3 = '''Hola,
    que tal?'''
``` 

**Operaciones básicas con cadenas de caracteres**

Algunas de las operaciones que puedo realizar con las cadenas de caracteres son:

* Concatenación: +: El operador + me permite unir datos de tipos secuenciales, en este caso dos cadenas de caracteres.

``` 
  >>> "hola " + "que tal"
  'hola que tal'
``` 
* Repetición: *: El operador * me permite repetir un dato de un tipo secuencial, en este caso de cadenas de caracteres.

``` 
  >>> "abc" * 3
  'abcabcabc'
``` 

* Indexación: Puedo obtener el dato de una secuencia indicando la posición en la secuencia. En este caso puedo obtener el carácter de la cadena indicando la posición (empezando por la posición 0).

``` 
  >>> cadena = "josé"
  >>> cadena[0]
  'j'
  >>> cadena[3]
  'é'
``` 

Para obtener la longitud de una cadena (número de caracteres que tiene), utilizamos la función len:

``` 
  >>> cadena = "josé"
  >>> len(cadena)
  4
```

**Comparación de cadenas**

Las cadenas se comparan carácter a carácter, en el momento en que dos caracteres no son iguales se compara alfabéticamente (es decir, se convierte a código unicode y se comparan).

Ejemplos

    >>> "a">"A"
    True

    >>> "informatica">"informacion"
    True

    >>> "abcde">"abcdef"
    False


### 2.7 De pseudocódigo a Python 3

**Leer variables por teclado**

* Leer cadenas de caracteres

En pseudocódigo:

Definir nombre Como Cadena;
Escribir "Dime tu nombre:";
Leer nombre;

En Python3:

``` 
nombre = input("Dime tu nombre:")
Leer números enteros
``` 

En pseudocódigo:

Definir numero Como Entero;
Escribir "Dime un número entero:";
Leer numero;

En Python3:

``` 
numero = int(input("Dime un número entero:"))
```

* Leer números reales

En pseudocódigo:

Definir numero Como Real;
Escribir "Dime un número real:";
Leer numero;

En Python3:

```
numero = float(input("Dime un número real:"))
```

**Escribir una variable en pantalla**

En pseudocódigo:

Escribir "Hola ",nombre;

En Python3:

```
print("Hola",nombre)
```

**Escribir sin saltar a otra línea**

En pseudocódigo:

Escribir Sin Saltar var," ";

En Python3:

``` 
print(var," ",end="")
``` 

**Asignar valor a una variable**

En pseudocódigo:

numero <- 7;

En Python3:

```
numero = 7
``` 

Por ejemplo para incrementar el valor de una variable, en pseudocódigo:

num <- num + 1

En python3 lo podemos hacer de dos maneras:

num = num +1
O de esta forma:

num += 1

**Calcular la parte entera de una división**

En pseudocódigo:

trunc(7/2)

En Python3:

7 // 2

**Calcular la raíz cuadrada**

En pseudocódigo:

raiz(9)

En Python3:

``` 
import math
math.sqrt(9)
``` 

**Obtener el carácter de una cadena**

En pseudocódigo:

subcadena(cadena,0,0)
En Python3:

``` 
cadena[0]
``` 

**Unir dos cadenas de caracteres**

En pseudocódigo:

cadena3 <- concatenar(cadena1,cadena2)

En Python3:

``` 
cadena3 = cadena1 + cadena2
``` 

**Convertir una cadena a Mayúsculas**

Lo veremos con detenimiento en las próximas unidades, pero vamos a usar el método de cadena upper:

En pseudocódigo:

cadena <- Mayusculas(cadena)

En Python3:

``` 
cadena = cadena.upper()
``` 

## 3. Estructuras de control

### 3.1 Alternativas

**Alternativa simple**

Al ejecutarse la instrucción if se evalúa la condición lógica. Si la condición lógica es True se ejecutan de manera secuencial el bloque de instrucciones . Si la condición es False no se ejecuta el bloque de instrucciones. Una vez ejecutado el if (opción verdadera o falsa) se continúa la ejecución de forma secuencial por la siguiente instrucción (bloque de instrucción no identado).

* Ejemplo
Programa que pida la edad y diga si es mayor de edad.

``` 
edad = int(input("Dime tu edad:"))
if edad>=18:
    print("Eres mayor de edad")
print("Programa terminado")
``` 

**Alternativa doble**

Al ejecutarse la instrucción if se evalúa la condición lógica. Si la condición lógica es True se ejecutan de manera secuencial el primer bloque de instrucciones. Si la condición es False se ejecuta el segundo bloque de instrucción. Una vez ejecutado el if (opción verdadera o falsa) se continúa la ejecución de forma secuencial por la siguiente instrucción (bloque de instrucción no identado).

* Ejemplo
Programa que pida la edad y diga si es mayor de edad o menor de edad.

```
edad = int(input("Dime tu edad:"))
if edad>=18:
    print("Eres mayor de edad")
else:
    print("Eres menor de edad")
print("Programa terminado")
``` 

**Alternativa múltiple**

En este caso tenemos varias opciones. Vamos preguntando por cada una de las opciones y según el valor de la expresión ejecutamos un bloque o otro. Esta estructura de control nos permite programar la lógica de la instrucción Segun del pseudocódigo.

Ejemplo
Programa que pide una nota de un examen por teclado y muestra la nota como “Sobresaliente”, “Notable”, “Bien”, “Suficiente”, “Suspendido”. En pseudocódigo podemos usar la instrucción Segun:

Proceso notas
    Definir nota como entero;
    Escribir "Dime tu nota:";
    Leer nota;
    Segun nota Hacer
        1,2,3,4: Escribir "Suspenso";
        5: Escribir "Suficiente";
        6,7: Escribir "Bien";
        8: Escribir "Notable";
        9,10: Escribir "Sobresaliente";
        De Otro Modo:
            Escribir "Nota incorrecta";
    FinSegun
    Escribir "Programa terminado";
FinProceso

En python3 utilizamos la alternativa múltiple:

``` 
nota = int(input("Dime tu nota:"))
if nota >=1 and nota <= 4:
    print("Suspenso")
elif nota == 5:
    print("Suficiente")
elif nota == 6 or nota == 7:
    print("Bien")
elif nota == 8:
    print("Notable")
elif nota ==9 or nota == 10:
    print("Sobresaliente")
else:
    print("Nota incorrecta")
print("Programa terminado")
``` 

### 3.2 While

La instrucción while ejecuta una secuencia de instrucciones mientras una condición sea verdadera.

``` 
while <condición>:
    <instrucciones>
``` 

Al ejecutarse esta instrucción, la condición es evaluada. Si la condición resulta verdadera, se ejecuta una vez la secuencia de instrucciones que forman el cuerpo del ciclo. Al finalizar la ejecución del cuerpo del ciclo se vuelve a evaluar la condición y, si es verdadera, la ejecución se repite. Estos pasos se repiten mientras la condición sea verdadera.

Se puede dar la circunstancia que las instrucciones del bucle no se ejecuten nunca, si al evaluar por primera vez la condición resulta ser falsa.

Si la condición siempre es verdadera, al ejecutar esta instrucción se produce un ciclo infinito. A fin de evitarlo, las instrucciones del cuerpo del ciclo deben contener alguna instrucción que modifique la o las variables involucradas en la condición, de modo que ésta sea falsificada en algún momento y así finalice la ejecución del ciclo.

* Ejemplo
* 
Crea un programa que pida al usuario una contraseña, de forma repetitiva mientras que no introduzca “asdasd”. Cuando finalmente escriba la contraseña correcta, se le dirá “Bienvenido” y terminará el programa.

``` 
secreto = "asdasd"
clave = input("Dime la clave:")
while clave != secreto:
    print("Clave incorrecta!!!")
    clave = input("Dime la clave:")
print("Bienvenido!!!")
print("Programa terminado")
``` 

**Instrucciones break y continue**

- break
  
Termina la ejecución del bucle, además no ejecuta el bloque de instrucciones.

Veamos un programa similar al anterior pero que tiene otra condición de salida:

``` 
secreto = "asdasd"
clave = input("Dime la clave:")
while clave != secreto:
    print("Clave incorrecta!!!")
    otra = input("¿Quieres introducir otra clave (S/N)?:")
    if otra.upper()=="N":
        break;
    clave = input("Dime la clave:")
if clave == secreto:
    print("Bienvenido!!!")
print("Programa terminado")
``` 

- continue
  
Deja de ejecutar las restantes instrucciones del bucle y vuelve a iterar.

Aunque podemos de hacerlo de varias formas, vamos a usar la instrucción continue para mostrar los número pares del 1 al 10:

``` 
cont = 0
while cont<10:
    cont = cont + 1
    if cont % 2 != 0:
        continue
    print(cont)
``` 

**Instrucción Repetir - Hasta Que**

En pseudocódigo podemos encontrar una instrucción Repetir - Hasta Que que nos permite ejecutar una secuencia de instrucciones hasta que la condición sea verdadera. Con esta estructura la secuencia de instrucciones que forma el cuerpo del ciclo se ejecuta una vez y luego se evalúa la condición. Esta estructura de control la podemos encontrar en muchos lenguajes de programación, pero en Python no existe. Podemos simular el comportamiento de esta estructura utilizando un bucle con while y con la instrucción break:

* Ejemplo
  
Crea un programa que pida al usuario una contraseña, de forma repetitiva mientras que no introduzca “asdasd”. Cuando finalmente escriba la contraseña correcta, se le dirá “Bienvenido” y terminará el programa.

En pseudocódigo:

Proceso login
    Definir secreto, clave como cadena;
    secreto <- "asdasd";
    Repetir
        Escribir "Dime la clave:";
        Leer clave;
        Si clave<>secreto Entonces
            Escribir "Clave incorrecta!!!";
        FinSi
    Hasta Que clave=secreto
    Escribir "Bienvenido!!!";
    Escribir "Programa terminado";
FinProceso

En python3:

``` 
secreto = "asdasd"
while True:
    clave = input("Dime la clave:")
    if clave != secreto:
        print("Clave incorrecta!!!")
    if clave == secreto:
        break;
print("Bienvenido!!!")
print("Programa terminado")
``` 

### 3.3 Repetitivas: For

La estructura for nos permite recorrer los elementos de una secuencia (lista, tupla, cadena de caracteres,…). sin embargo en esta unidad vamos a a prender a usar for de forma similar a la instrucción Para de pseudocódigo, es decir, ejecutar una secuencia de instrucciones un número determinado de veces, desde un valor inicial, hasta un valor final y con un posible incremento. Para ello vamos a usar el tipo de datos range que nos permite generar listas de números. Vamos a usar for para crear bucles de instrucciones donde sabemos a priori el número de iteraciones que hay que realizar.

**Ejemplos**

* Ejemplo 1

Escribir en pantalla del 1 al 10.

En pseudocódigo:

Proceso Contar
    Definir var como Entero;
    Para var<-1 Hasta 10 Hacer
        Escribir Sin Saltar var," ";
    FinPara
FinProceso

En python3:

``` 
for var in range(1,11):
    print(var," ",end="")
``` 

* Ejemplo 2
  
Escribir en pantalla de 10 al 1.

En pseudocódigo:

Proceso ContarDescesdente
    Definir var como Entero;
    Para var<-10 Hasta 1 Con Paso -1 Hacer
        Escribir Sin Saltar var," ";
    FinPara
FinProceso

En python3:

``` 
for var in range(10,0,-1):
    print(var," ",end="")
``` 

* Ejemplo 3

Escribir los número pares desde el 2 al 10.

En pseudocódigo:

Proceso ContarPares
    Definir var como Entero;
    Para var<-2 Hasta 10 Con Paso 2 Hacer
        Escribir Sin Saltar var," ";
    FinPara
FinProceso

En python3:

``` 
for var in range(2,11,2):
    print(var," ",end="")
``` 

### 3.4 Uso específico de variables: Contadores, acumuladores e indicadores

**Contadores**

Un contador es una variable entera que la utilizamos para contar cuando ocurre un suceso. Un contador:

Se inicializa a un valor inicial.

  cont = 0;

Se incrementa, cuando ocurre el suceso que estamos contado se le suma 1.

  cont = cont + 1;

Otra forma de incrementar el contador:

  cont += 1

* Ejemplo
  
Introducir 5 número y contar los números pares.

``` 
cont = 0;
for var in range(1,6):
    num = int(input("Dime un número:"))
    if num % 2 == 0:
        cont = cont + 1
print("Has introducido ",cont," números pares.")
``` 

**Acumuladores**

Un acumulador es una variable numérica que permite ir acumulando operaciones. Me permite ir haciendo operaciones parciales. Un acumulador:

Se inicializa a un valor inicial según la operación que se va a acumular: a 0 si es una suma o a 1 si es un producto.
Se acumula un valor intermedio.

  acum  =  acum + num;

* Ejemplo
  
Introducir 5 número y sumar los números pares.

``` 
suma = 0;
for var in range(1,6):
    num = int(input("Dime un número:"))
    if num % 2 == 0:
        suma = suma + num
print("La suma de los números pares es ",suma)
``` 

**Indicadores**

Un indicador es una variable lógica, que usamos para recordar o indicar algún suceso. Un indicador:

Se inicializa a un valor lógico que indica que el suceso no ha ocurrido.

indicador = False

Cuando ocurre el suceso que queremos recordar cambiamos su valor.

indicador = True

* Ejemplo
  
Introducir 5 número e indicar si se ha introducido algún número par.

```
indicador  =  False;
for var in range(1,6):
    num = int(input("Dime un número:"))
    if num % 2 == 0:
        indicador  = True
if indicador:
    print("Has introducido algún número par")
else:
    print("No has introducido algún número par")
``` 


## 4. Tipos de datos: Secuencias

### 4.1 Cadenas de caracteres

Como vimos en una unidad anterior, las cadenas de caracteres (str): Me permiten guardar secuencias de caracteres.

Además de las operaciones que ya hemos estudiado:

- Concatenación: +: El operador + me permite unir datos de tipos secuenciales, en este caso dos cadenas de caracteres.
- Repetición: *: El operador * me permite repetir un dato de un tipo secuencial, en este caso de cadenas de caracteres.
- Indexación: Puedo obtener el dato de una secuencia indicando la posición en la secuencia. En este caso puedo obtener el carácter de la cadena indicando la posición (empezando por la posición 0).

Para obtener la longitud de una cadena (número de caracteres que tiene), utilizamos la función len.
Tenemos más operaciones que podemos realizar:

Otras operaciones con cadenas de caracteres
Las cadenas de caracteres se pueden recorrer:

``` 
  >>> cadena = "informática"
  >>> for caracter in cadena:
  ...    print(caracter,end="")
  ...
  informática
``` 

Operadores de pertenencia: Se puede comprobar si un elemento (subcadena) pertenece o no a una cadena de caracteres con los operadores in y not in.

``` 
  >>> "a" in cadena
  True
  >>> "b" in cadena
  False
  >>> "a" not in cadena
  False
``` 

* Slice (rebanada): Puedo obtener una subcadena de la cadena de caracteres. Se indica el carácter inicial, y el carácter final, además podemos indicar opcionalmente un salto. Si no se indica el carácter inicial se supone que es desde el primero, sino se indica el carácter final se supone que es hasta el final. Por último podemos usar salto negativo para empezar a contar desde el final.

Como resumen de las distintas posibilidades podemos indicar:

* cadena[start:end] # Elementos desde la posición start hasta end-1
* cadena[start:] # Elementos desde la posición start hasta el final
* cadena[:end] # Elementos desde el principio hasta la posición end-1
* cadena[:] # Todos Los elementos
* cadena[start:end:step] # Igual que el anterior pero dando step saltos.

Veamos algunos ejemplos:

``` 
    >>> cadena[2:5]
    'for'
    >>> cadena[2:7:2]
    'frá'
    >>> cadena[:5]
    'infor'
    >>> cadena[5:]
    'mática'
    >>> cadena[-1:-3]
    ''
    >>> cadena[::-1]
    'acitámrofni'
``` 

**Conversión de tipos**

Podemos convertir cualquier número en una cadena de caracteres utilizando la función str:

``` 
    >>> cad = str(7.8)
    >>> type(cad)
    <class 'str'>
    >>> print(cad)
    7.8
``` 

### 4.2 Inmutabilidad o mutabilidad de las cadenas

Cuando creamos una variable de tipo cadena de caracteres, estamos creando un objeto de la clase str. Una clase especifica lo que podemos guardar en un tipo de datos y las operaciones que pueden realizar, cada vez que creamos una variable de una determinada clase, creamos un objeto, que además de guardar información (en nuestro caso los caracteres de la cadena) puede realizar distintas operaciones que llamamos métodos.

Nosotros ya hemos usado un método de la clase str. El método upper() nos permite convertir la cadena a mayúsculas.

¿Qué significa que las cadenas de caracteres son inmutables?

No podemos cambiar los caracteres de una cadena de la siguiente forma:

``` 
>>> cadena = "informática"
>>> cadena[2]="g"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

Esto implica que al usar un método la cadena original no cambia, el método devuelve otra cadena modificada. Veamos un ejemplo:

``` 
>>> cadena = "informática"
>>> cadena.upper()
'INFORMÁTICA'
>>> cadena
'informática'
``` 

Si queremos cambiar la cadena debemos modificar su valor con el operador de asignación:

``` 
>>> cadena = cadena.upper()
>>> cadena
'INFORMÁTICA'
``` 

### 4.3 Métodos con las cadenas

Aunque las cadenas de caracteres tiene muchos métodos definidos, vamos a estudiar los más importantes:

**Métodos de formato**

* capitalize() nos permite devolver la cadena con el primer carácter en mayúsculas.

```
>>> cad = "hola, como estás?"
>>> print(cad.capitalize())
Hola, como estás?
``` 

* lower() y upper() convierte la cadena de caracteres en minúsculas y mayúsculas respectivamente.

``` 
>>> cad = "Hola Mundo" 
>>> print(cad.lower())
hola mundo

>>> cad = "hola mundo"
>>> print(cad.upper())
HOLA MUNDO
``` 

* swapcase(): devuelve una cadena nueva con las minúsculas convertidas a mayúsculas y viceversa.

```
>>> cad = "Hola Mundo"
>>> print(cad.swapcase())
hOLA mUNDO
``` 

* title(): Devuelve una cadena con los primeros caracteres en mayúsculas de cada palabra.

```
>>> cad = "hola mundo"
>>> print(cad.title())
Hola Mundo
``` 

**Métodos de búsqueda**

* count(): Es un método al que indicamos como parámetro una subcadena y cuenta cuantas apariciones hay de esa subcadena en la cadena.

```
>>> cad = "bienvenido a mi aplicación"
>>> cad.count("a")
3
``` 

Además podemos indicar otro parámetro para indicar la posición desde la que queremos iniciar la búsqueda. Y otro parámetro optativo para indicar la posición final de búsqueda.

``` 
>>> cad.count("a",16)
2
>>> cad.count("a",10,16)
1
``` 

* find() nos devuelve la posición de la subcadena que hemos indicado como parámetro. Sino se encuentra se devuelve -1.

```
>>> cad.find("mi")
13
>>> cad.find("hola")
-1
``` 

**Métodos de validación**

* startswith() nos indica con un valor lógico si la cadena empieza por la subcadena que hemos indicado como parámetro. Podemos indicar también con otro parámetro la posición donde tiene que buscar.

``` 
>>> cad.startswith("b")
True
>>> cad.startswith("m")
False
>>> cad.startswith("m",13)
True
``` 

* endswith() igual que la anterior pero indica si la cadena termina con la subcadena indicada. En este caso, se puede indicar la posición de inicio y final de búsqueda.

``` 
>>> cad.endswith("ción")
True
>>> cad.endswith("ción",0,10)
False
>>> cad.endswith("nido",0,10)
True
```

* Otras funciones de validación: isdigit(), islower(), isupper(), isspace(), istitle(),…

**Métodos de sustitución**

* replace(): Devuelve una cadena donde se ha sustituido las apariciones de la primera subcadena indicada por la segunda subcadena indicada como parámetro.

``` 
>>> buscar = "nombre apellido"
>>> reemplazar_por = "Juan Pérez" 
>>> print ("Estimado Sr. nombre apellido:".replace(buscar, reemplazar_por)) 
Estimado Sr. Juan Pérez:
```

* strip(): Devuelve una cadena donde se han quitado los espacios del principio y del final. Si indicamos una subcadena como parámetro quitará dicha subcadena del principio y del final.

``` 
>>> cadena = "   www.eugeniabahit.com   " 
>>> print(cadena.strip())
www.eugeniabahit.com
>>> cadena="00000000123000000000"
>>> print(cadena.strip("0"))
123
``` 

**Métodos de unión y división**

* Aunque todavía no lo hemos estudiado, el método split() nos permite convertir una cadena en una lista. Lo usaremos más adelante.

``` 
>>> hora = "12:23:12"
>>> print(hora.split(":"))
['12', '23', '12']
```

* splitlines(): Nos permite separar las líneas que hay en una cadena (indicada con el carácter \n) en una lista.

``` 
>>> texto = "Linea 1\nLinea 2\nLinea 3" 
>>> print(texto.splitlines())
['Linea 1', 'Linea 2', 'Linea 3']
``` 

### 4.4 Listas

Si queremos guardar un conjunto de valores, en pseudocódigo utilizamos loas arreglos. Un array (o arreglo) es una estructura de datos con elementos homogéneos, del mismo tipo, numérico o alfanumérico, reconocidos por un nombre en común.

Hay muchos lenguajes que implementan los arrays, pero esta estructura tiene dos limitaciones: son homogéneas, es decir sólo se pueden guardar datos del mismo tipo, y son estáticas, a la hora de declarar se indican las posiciones y la longitud del array no se puede cambiar durante la ejecución del programa.

En Python no existen los arrays, tenemos varios tipos de datos que nos permiten guardar conjuntos de informaciones. En esta unidad vamos a estudiar las Listas. Las listas (list) me permiten guardar un conjunto de datos que se pueden repetir y que pueden ser de distintos tipos. Además esta estructura es dinámica, en cualquier momento de la ejecución del programa puedo añadir o eliminar elementos de la lista.

**Construcción de una lista**

Para crear una lista puedo usamos los caracteres [ y ]:

``` 
>>> lista1 = []
>>> lista2 = ["a",1,True]
``` 

**Operaciones básicas con listas**

Las listas son secuencias, a las que podemos realizar las siguientes operaciones. Vamos a ver distintos ejemplos partiendo de la siguiente lista:

lista = [1,2,3,4,5,6]

Las listas se pueden recorrer:

``` 
  >>> for num in lista:
  ...   print(num,end="")
  123456
``` 

Con la instrucción for podemos recorrer más de una listas, utilizando la función zip. Veamos un ejemplo:

``` 
  >>> lista2 = ["a","b","c","d","e"]
  >>> for num,letra in zip(lista,lista2):
  ...     print(num,letra)
  ...
  1 a
  2 b
  3 c
  4 d
  5 e
``` 

* Operadores de pertenencia: Se puede comprobar si un elemento pertenece o no a una lista con los operadores in y not in.

``` 
  >>> 2 in lista
  True
  >>> 8 not in lista
  True
``` 

* Concatenación: El operador + me permite unir datos de tipos listas:

``` 
  >>> lista + [7,8,9]
  [1, 2, 3, 4, 5, 6, 7, 8, 9]
``` 

* Repetición: El operador * me permite repetir un dato de una lista:

``` 
  >>> lista * 2
  [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
``` 

* Indexación: Puedo obtener el dato de una secuencia indicando la posición en la secuencia.

``` 
  >>> lista[3]
  4
``` 

Cada elemento tiene un índice, empezamos a contar por el elemento en el índice 0. Si intento acceder a un índice que corresponda a un elemento que no existe obtenemos una excepción IndexError.

``` 
  >>> lista1[12]
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module
  IndexError: list index out of range  
``` 

Se pueden utilizar índices negativos:

``` 
  >>> lista[-1]
  6
``` 

* Slice (rebanada): Puedo obtener una subsecuencia de los datos de una lista. Funciona de forma similar como en las cadenas, veamos algunos ejemplos:

``` 
  >>> lista[2:4]
  [3, 4]
  >>> lista[1:4:2]
  [2, 4]
  >>> lista[:5]
  [1, 2, 3, 4, 5]
  >>> lista[5:]
  [6, 1, 2, 3, 4, 5, 6]
  >>> lista[::-1]
  [6, 5, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1]
``` 

**Funciones predefinidas que trabajan con listas**

``` 
>>> lista1 = [20,40,10,40,50]
>>> len(lista1)
5
>>> max(lista1)
50
>>> min(lista1)
10
>>> sum(lista1)
150
>>> sorted(lista1)
[10, 20, 30, 40, 50]
>>> sorted(lista1,reverse=True)
[50, 40, 30, 20, 10]
``` 

**Listas multidimensionales**

A la hora de definir las listas hemos indicado que podemos guardar en ellas datos de cualquier tipo, y evidentemente podemos guardar listas dentro de listas.

``` 
>>> tabla = [[1,2,3],[4,5,6],[7,8,9]]
>>> tabla[1][1]
5

>>> for fila in tabla:
...   for elem in fila:
...      print(elem,end="")
...   print()

123
456
789
``` 

### 4.5 Mutabilidad de las listas

Al igual que las cadenas el tipo de datos lista es una clase, cada vez que creamos una variable de la clase lista estamos creando un objeto que además de guardar un conjunto de datos, posee un conjunto de métodos que nos permiten trabajar con la lista.

**¿Qué significa que las listas son mutables?**

Los elementos de las listas se pueden modificar:

``` 
>>> lista1 = [1,2,3]
>>> lista1[2]=4
>>> lista1
[1, 2, 4]
>>> del lista1[2]
>>> lista1
[1, 2]
``` 

Esto también ocurre cuando usamos los métodos, es decir, los métodos de las listas modifican el contenido de la lista, por ejemplo si usamos el método append() para añadir un elemento a la lista:

``` 
>>> lista1.append(3)
>>> lista1
[1, 2, 3]
``` 

Como vemos la lista lista1 se ha modificado.

**¿Cómo se copian las listas?**

Para copiar una lista en otra no podemos utilizar el operador de asignación:

``` 
>>> lista1 = [1,2,3]
>>> lista2 = lista1
>>> lista1[1] = 10
>>> lista2
[1, 10, 3]
``` 

El operador de asignación no crea una nueva lista, sino que nombra con dos nombres distintos a la misma lista, por lo tanto la forma más fácil de copiar una lista en otra es:

``` 
>>> lista1 = [1,2,3]
>>> lista2=lista1[:]
>>> lista1[1] = 10
>>> lista2
[1, 2, 3]
``` 

### 4.6 Métodos principales de listas

**Métodos de inserción: append, extend, insert**

* append(): añade un elemento a la lista:

``` 
>>> lista = [1,2,3]
>>> lista.append(4)
>>> lista
[1, 2, 3, 4]
``` 

* extend(): Une dos listas:

``` 
>>> lista2 = [5,6]
>>> lista.extend(lista2)
>>> lista
[1, 2, 3, 4, 5, 6]
``` 

* insert(): Añade un elemento en un posición indicada de la lista:

``` 
>>> lista.insert(1,100)
>>> lista
[1, 100, 2, 3, 4, 5, 6]
``` 

**Métodos de eliminación: pop, remove**

* pop(): elimina un elemento de la lista y lo devuelve. Se puede indicar el índice del elemento que queremos obtener como parámetro, sino se indica se devuelve y elimina el último:

```
>>> lista.pop()
6
>>> lista
[1, 100, 2, 3, 4, 5]

>>> lista.pop(1)
100
>>> lista
[1, 2, 3, 4, 5]
``` 

* remove(): Elimina el elemento de la lista indicado por la posición:

``` 
>>> lista.remove(3)
>>> lista
[1, 2, 4, 5]
``` 

**Métodos de ordenación: reverse, sort**

* reverse(): Modifica la lista invirtiendo los elementos:

``` 
>>> lista.reverse()
>>> lista
[5, 4, 2, 1]
``` 

* sort(): Modifica la lista ordenando los elementos, se puede indicar el sentido de la ordenación:

``` 
>>> lista.sort()
>>> lista
[1, 2, 4, 5]

>>> lista.sort(reverse=True)
>>> lista
[5, 4, 2, 1]

>>> lista=["hola","que","tal","Hola","Que","Tal"]
>>> lista.sort()
>>> lista
['Hola', 'Que', 'Tal', 'hola', 'que', 'tal']
``` 

**Métodos de búsqueda: count, index**

* count(): devuelve el número de apariciones de un elemento en la lista:

```
>>> lista.count(5)
1
``` 

* index(): Nos devuelve la posición de la primera aparición del elemento indicado. Se puede indicar la posición inicial y final de búsqueda:

```
>>> lista.append(5)
>>> lista
[5, 4, 2, 1, 5]
>>> lista.index(5)
0
>>> lista.index(5,1)
4
>>> lista.index(5,1,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 5 is not in list
``` 

Si no encuentra el elemento nos da una excepción.


### 4.7 Tuplas

Las tuplas (tuple): Sirven para los mismo que las listas (me permiten guardar un conjunto de datos que se pueden repetir y que pueden ser de distintos tipos), pero en este caso es un tipo inmutable.

**Construcción de una tupla**

Para crear una lista puedo usar los caracteres ( y ):

``` 
>>> tupla1 = ()
>>> tupla2 = ("a",1,True)
``` 

**Operaciones básicas con tuplas**

En las tuplas se pueden realizar las siguientes operaciones:

- Las tuplas se pueden recorrer.
- Operadores de pertenencia: in y not in.
- Concatenación: +
- Repetición: *
- Indexación
- Slice
- Entre las funciones definidas podemos usar: len, max, min, sum, sorted.

Las tuplas son inmutables

``` 
>>> tupla = (1,2,3)
>>> tupla[1]=5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
``` 

**Métodos principales**

* Métodos de búsqueda: count, index

``` 
>>> tupla = (1,2,3,4,1,2,3)
>>> tupla.count(1)
2

>>> tupla.index(2)
1
>>> tupla.index(2,2)
5
``` 










